#!/bin/bash
# Author: Franck Jouvanceau
# Powerline prompt with AWK (bash/zsh/ksh)

[ "$1" = activate ] && cat $0 && exit 0
type typeset >/dev/null 2>&1 || alias typeset=''  # ash no typeset
if [ "$ZSH_VERSION" ];then
    setopt PROMPT_SUBST
    setopt sh_word_split # for i in $var
fi

pwline() {
    : ${COLUMNS:=$(stty size 2>/dev/null)} # ash no $COLUMNS
    COLUMNS=${COLUMNS#* }
    [ -x /bin/nawk ] && AWK=nawk || AWK=awk
    $AWK -v pcol="$ps1_colors" -v columns="$COLUMNS" '
    function init_symbols() {
        sym[">"] = ""; sep[">"] = ""; rev[">"]=0 # \ue0b0 \ue0b1
        sym[")"] = ""; sep[")"] = ""; rev[")"]=0 # \ue0b4 \ue0b5
        sym["<"] = ""; sep["<"] = ""; rev["<"]=1 # \ue0b2 \ue0b3
        sym["("] = ""; sep["("] = ""; rev["("]=1 # \ue0b6 \ue0b7
    }
    function init_colors() {
        csi = "\033["
        c = "black red green yellow blue magenta cyan white"
        split(c, co)
        for (i in co) {
            colors[co[i]] = csi i+29 "m"
            colors["l"co[i]] = csi i+89 "m"
            colors["b"co[i]] = csi i+39 "m"
            colors["bl"co[i]] = csi i+99 "m"
        }
        colors["reset_all"] = csi "0m"
        colors["reset"] = csi "39m"
        colors["breset"] = csi "49m"
        colors["wrapoff"] = csi "?7l"
        colors["wrapon"] = csi "?7h"
    }
    function getcols(info,    colinfo, i) {
        split(info, colinfo, "/")
        i=1
        if (colinfo[i] in sym)
            symbol = colinfo[i++]
        #print("\n="info, colinfo[i], i)
        if (bg) return
        if (colinfo[i] in colors)
            bg = colinfo[i]
        fg = colinfo[i+1] == "" ? "lwhite" : colinfo[i+1]
        sepcol = colinfo[i+2]
    }
    function getbgfg(i, info) {
        bg = ""
        getcols(info)
        getcols(pcols[i])
    }
    function gettext(info) {
        sub("[^:]*:", "", info)
        gsub("[|]+[|]", "|", info)
        gsub("^[|]|[|]$","", info)
        gsub("[|]", " | ", info)
        return info
    }
    BEGIN {
        pw_sep = ""
        pw_rsep = ""
        init_colors()
        init_symbols()
        split(pcol, pcols, " ")
        printf("%s", colors["wrapoff"])
        #pw_symbol = sprintf("%c", strtonum("0xE0B0"))
        for (i=1;i<ARGC;i++) {
            text=ARGV[i]
            if (text=="|") {
                emptywidth = columns - width -1 # avoid last column for resize
                for(j=ARGC-1;j>i;j--) {
                    text = gettext(ARGV[j])
                    if (text == "") continue
                    gsub("^ +| +$", "", text)
                    if (text in sym)
                        if (emptywidth - length(gettext(ARGV[j-1])) > 4)
                            emptywidth--
                        else
                            delete ARGV[j]
                    else if (emptywidth - length(text) > 3)
                        emptywidth -= length(text) + 3
                    else
                        delete ARGV[j]
                }
                printf("%*s", emptywidth, " ") # busybox for(j=0;j<emptywidth;j++) printf(" ")
                continue
            }
            split(text, colinfo, ":")
            getbgfg(i, colinfo[1])
            text = gettext(text)
            if (! text) continue
            gsub("^ +| +$", "", text)
            sp = " "
            if (text == symbol) { bg="reset"; width++ }
            else if (text == "") { text="";sp=""; width+=1 }
            else width += length(text) + 3
            gsub("[|]", colors[sepcol] sep[symbol] colors[fg], text)

            if (rev[symbol]) {
                printf("%s", colors[bg] sym[symbol])
                if (text!=symbol) 
                    printf("%s", colors[fg] colors["b"bg] sp text sp colors[bg])
            } else {
                printf("%s", colors["b"bg] sym[symbol])
                if (text!=symbol)
                    printf("%s", colors[fg] sp text sp colors["reset_all"] colors[bg] colors["b"bg])
            }
        }
        #if (! rev)
        #    printf("%s", colors[bg] colors["breset"] symbol)
        printf("%s%s\n", colors["reset_all"], colors["wrapoff"])
    }' "$@"
}


ps1_git_branch() {
    typeset git_head=.git/HEAD i git_branch
    for i in . . . . . .;do
        [ -r "$git_head" ] && break
        git_head="../$git_head"
    done
    [ ! -r "$git_head" ] && echo ':' && return
    git_branch=$(sed -e 's#.*/##' "$git_head")
    [ "$skip_git_status" ] && echo "${ps1_git_colors% *}:$git_branch" && return
    [[ "$(git status -uno --no-ahead-behind 2> /dev/null |tail -n1)" = "nothing to commit"* ]] && echo "${ps1_git_colors% *}:$git_branch" || echo "${ps1_git_colors#* }:$git_branch"
    #git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/'
}

ps1_userhost() {
    typeset hostname=$(uname -n)
    echo $USER@${hostname%%.*}
}

ps1_cwd() {
    typeset spwd=$PWD 
    typeset -i cols=${COLUMNS:-80}
    [[ $PWD = $HOME* ]] && spwd="~${PWD#$HOME}"
    [ ${#spwd} -gt $(($cols-30)) ] && spwd="${spwd:0:7}...${spwd:$((${#spwd}-$cols-40))}"
    echo "$spwd"
}

ps1_exit_status() {
    [ "$1" = 0 ] && echo "${ps1_exit_colors% *}:"|| echo "${ps1_exit_colors#* }:$1"
}

ps1_info() {
    eval echo -n \""$ps1_info"\"
    for i in $ps1_info_vars;do
        eval echo -n \"'|${'"$i"'}'\"
    done
}

ps1_uidprompt() {
    [ "$USER" = root ] && echo '#' || echo '$'    
}

ps1_prompt() {
    if [ "$BASH" ];then
        shell=bash
        prompt='\$'
        pre='\['
        post='\]'
    elif [ "$ZSH_VERSION" ];then
        shell=zsh
        prompt='%(!.#.$)'
        pre='%{'
        post='%}'
    else
        shell=other
        prompt="'$(ps1_uidprompt)'"
    fi
    echo -ne "$pre"'$(pwline '
    awk -v shell="$shell" 'BEGIN {
        cmd["exit_status"] = "$(ps1_exit_status $?)"
        if (shell == "bash") {
            cmd["userhost"] = "\\u@\\h"
            cmd["cwd"] = "\\w"
            cmd["time"] = "\\A"
            cmd["prompt"] = "\\$"
        } else if (shell == "zsh") {
            cmd["userhost"] = "$(print -P %n@%m)"
            cmd["time"] = "$(print -P %T)"
            cmd["prompt"] = "%(!.#.$)"
        } else 
            cmd["time"] = "$(date +%H:%M)"
        nb = split(ARGV[1], segments, " ")
        for (i=1; i<=nb; i++) {
            n = split(segments[i], info, ":")
            if (n==1) {
                printf("\"%s\" ", info[1])
                continue
            }
            sep=":"
            if (info[1]~/auto/) { sep = ""; sub("auto","",info[1]) }
            if (info[2] in cmd)
                printf("\"%s%s%s\" ", info[1], sep, cmd[info[2]])
            else
                printf("\"%s%s$(ps1_%s)\" ", info[1], sep, info[2])
        }
    }' "$@"
    echo ")$post"
    echo "$prompt "
}

: ${PROMPT_DIRTRIM:=5}
: #${ps1_info:='$(echo uid:$(id -u))'}
: ${ps1_info_vars:='client_id ORACLE_SID VIRTUAL_ENV##*[/\\\\]'}     
: ${ps1_exit_colors:="green red"}
: ${ps1_git_colors:="green yellow/black"}
# create powerline prompt
# (exit_status(user@host)cwd>gitbranch>     ----->       <info1<info2...(time)
PS1="$(ps1_prompt "(/auto:exit_status (/blue:userhost )/lblack:cwd >/auto:git_branch > \
                                            | </lblue/black/blue:info (/blue:time )")"
