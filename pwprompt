#!/bin/bash
# Author: Franck Jouvanceau
[ "$1" = activate ] && cat $0 && exit 0
type typeset >/dev/null 2>&1 || alias typeset=''  # ash no typeset

pwline() {
    : ${COLUMNS:=$(stty size)} # ash no $COLUMNS
    COLUMNS=${COLUMNS#* }

    awk -v pcol="$ps1_colors" -v columns="$COLUMNS" '
    function init_symbols() {
        sym[">"] = ""; sep[">"] = ""; rev[">"]=0 # \ue0b0 \ue0b1
        sym[")"] = ""; sep[")"] = ""; rev[")"]=0 # \ue0b4 \ue0b5
        sym["<"] = ""; sep["<"] = ""; rev["<"]=1 # \ue0b2 \ue0b3
        sym["("] = ""; sep["("] = ""; rev["("]=1 # \ue0b6 \ue0b7
    }
    function init_colors() {
        csi = "\033["
        c = "black red green yellow blue magenta cyan white"
        split(c, co)
        for (i in co) {
            colors[co[i]] = csi i+29 "m"
            colors["l"co[i]] = csi i+89 "m"
            colors["b"co[i]] = csi i+39 "m"
            colors["bl"co[i]] = csi i+99 "m"
        }
        colors["reset_all"] = csi "0m"
        colors["reset"] = csi "39m"
        colors["breset"] = csi "49m"
    }
    function getcols(info,    colinfo, i) {
        split(info, colinfo, "/")
        i=1
        if (colinfo[i] in sym)
            symbol = colinfo[i++]
        #print("\n="info, colinfo[i], i)
        if (bg) return
        if (colinfo[i] in colors)
            bg = colinfo[i]
        fg = colinfo[i+1] == "" ? "lwhite" : colinfo[i+1]
        sepcol = colinfo[i+2]
    }
    function getbgfg(i, info) {
        bg = ""
        getcols(info)
        getcols(pcols[i])
    }
    function gettext(info) {
        sub("[^:]*:", "", info)
        gsub("[|]+[|]", "|", info)
        gsub("^[|]|[|]$","", info)
        gsub("[|]", " | ", info)
        return info
    }
    BEGIN {
        pw_sep = ""
        pw_rsep = ""
        init_colors()
        init_symbols()
        split(pcol, pcols, " ")
        #pw_symbol = sprintf("%c", strtonum("0xE0B0"))
        for (i=1;i<ARGC;i++) {
            text=ARGV[i]
            if (text=="|") {
                emptywidth = columns - width
                for(j=ARGC-1;j>i;j--) {
                    text = gettext(ARGV[j])
                    if (text == "") continue
                    gsub("^ +| +$", "", text)
                    if (text in sym)
                        if (emptywidth - length(gettext(ARGV[j-1])) > 4)
                            emptywidth--
                        else
                            delete ARGV[j]
                    else if (emptywidth - length(text) > 3)
                        emptywidth -= length(text) + 3
                    else
                        delete ARGV[j]
                }
                printf("%*s", emptywidth, " ") # busybox for(j=0;j<emptywidth;j++) printf(" ")
                continue
            }
            split(text, colinfo, ":")
            getbgfg(i, colinfo[1])
            text = gettext(text)
            if (! text) continue
            gsub("^ +| +$", "", text)
            sp = " "
            if (text == symbol) { bg="reset"; width++ }
            else if (text == "") { text="";sp=""; width+=1 }
            else width += length(text) + 3
            gsub("[|]", colors[sepcol] sep[symbol] colors[fg], text)

            if (rev[symbol]) {
                printf("%s", colors[bg] sym[symbol])
                if (text!=symbol) 
                    printf("%s", colors[fg] colors["b"bg] sp text sp colors[bg])
            } else {
                printf("%s", colors["b"bg] sym[symbol])
                if (text!=symbol)
                    printf("%s", colors[fg] sp text sp colors["reset_all"] colors[bg] colors["b"bg])
            }
        }
        #if (! rev)
        #    printf("%s", colors[bg] colors["breset"] symbol)
        printf("%s\n", colors["reset_all"])
    }' "$@"
}


parse_git_branch() {
    typeset git_head=.git/HEAD i git_branch
    for i in . . . . . .;do
        [ -r "$git_head" ] && break
        git_head="../$git_head"
    done
    [ -r "$git_head" ] || return
    git_branch=$(sed -e 's#.*/##' "$git_head")
    [ "$skip_git_status" ] && echo "${ps1_git_colors% *}:$git_branch" && return
    [[ "$(git status -uno 2> /dev/null |tail -n1)" = "nothing to commit"* ]] && echo "${ps1_git_colors% *}:$git_branch" || echo "${ps1_git_colors#* }:$git_branch"
    #git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/'
}

short_hostname() {
    typeset hostname=$(uname -n)
    echo ${hostname%%.*}
}

short_pwd() {
    typeset spwd=$PWD 
    typeset -i cols=${COLUMNS:-80}
    [[ $PWD = $HOME* ]] && spwd="~${PWD#$HOME}"
    [ ${#spwd} -gt $(($cols-30)) ] && spwd="${spwd:0:7}...${spwd:$((${#spwd}-$cols-40))}"
    echo "$spwd"
}

exit_status_color() {
    [ "$1" = 0 ] && echo "${ps1_exit_colors% *}:"|| echo "${ps1_exit_colors#* }:$1"
}

ps1_info() {
    eval echo -n \""$ps1_info"\"
    for i in $ps1_vars;do
        eval echo -n \"'|$'"${i}"\"
    done
}

ps1_prompt() {
    typeset exit_status='"$(exit_status_color $?)"'
    typeset git_branch='"$(parse_git_branch)"'
    typeset other_info='":$(ps1_info)"'
    typeset cur_dir='":$(short_pwd)"'
    typeset pre="" post="" prompt=""
    if [ "$BASH" ];then
        user_host='":\u@\h"'
        cur_dir='":\w"'
        time='":\A"'
        pre='\['
        post='\]'
        prompt='\$'
    elif [ "$ZSH_VERSION" ];then
        setopt PROMPT_SUBST
        setopt sh_word_split # for i in $var
        # cannot use directly ":%n@%m" ":%d" because substituted after execution (width calculation impossible)
        user_host='":$(print -P "%n@%m")"'
        time='":$(print -P "%T")"'
        pre='%{'
        post='%}'
        prompt='%(!.#.$)'
    else
        user_host='":$USER@$(short_hostname)"'
        time='":$(date +%H:%M)"'
        [ "$USER" = root ] && prompt='#' || prompt='$'
    fi
    PS1="$pre\$(pwline $exit_status $user_host $cur_dir $git_branch '>' '|' $other_info $time ')')$post
$prompt "
}
: ${PROMPT_DIRTRIM:=4}
: ${ps1_info:='${VIRTUAL_ENV##*[/\\\\]}'}
: ${ps1_vars:='client_id ORACLE_SID'}
: ${ps1_exit_colors:="green red"}
: ${ps1_git_colors:="green yellow/black"}
: ${ps1_colors:="(/green (/blue )/lblack >/yellow/black > | </lblue/black/blue (/blue )"}
ps1_prompt
